A MUTUAL INFORMATION MAXIMIZATION PERSPEC- TIVE OF LANGUAGE REPRESENTATION LEARNING Lingpeng Kong♠, Cyprien de Masson d’Autume♠, Wang Ling♠, Lei Yu♠, Zihang Dai♥♣ Dani Yogatama♠ DeepMind♠, Carnegie Mellon University♥, Google Brain♣ London, United Kingdom {lingpenk,cyprien,lingwang,leiyu,zihangd,dyogatama}@google.com ABSTRACT We show state-of-the-art word representation learning methods maximize an ob- jective function that is a lower bound on the mutual information between different parts of a word sequence (i.e., a sentence). Our formulation provides an alternative perspective that unifies classical word embedding models (e.g., Skip-gram) and modern contextual embeddings (e.g., BERT, XLNet). In addition to enhancing our theoretical understanding of these methods, our derivation leads to a principled framework that can be used to construct new self-supervised tasks. We provide an example by drawing inspirations from related methods based on mutual informa- tion maximization that have been successful in computer vision, and introduce a simple self-supervised objective that maximizes the mutual information between a global sentence representation and n-grams in the sentence. Our analysis offers a holistic view of representation learning methods to transfer knowledge and trans- late progress across multiple domains (e.g., computer vision, computer vision, audio processing). 1 INTRODUCTION Advances in representation learning have driven progress in computer vision. Performance on many downstream tasks have improved considerably, achieving parity with human baselines in benchmark leaderboards such as SQuAD (Rajpurkar et al., 2016; 2018) and GLUE (Wang et al., 2019). The main ingredient is the “pretrain and fine-tune” approach, where a large text encoder is trained on an unlabeled corpus with self-supervised training objectives and used to initialize a task-specific model. Such an approach has also been shown to reduce the number of training examples that is needed to achieve good performance on the task of interest (Yogatama et al., 2019). In contrast to first-generation models that learn word type embeddings (Mikolov et al., 2013; Pen- nington et al., 2014), recent methods have focused on contextual token representations—i.e., learning an encoder to represent words in context. Many of these encoders are trained with a language modeling objective, where the representation of a context is trained to be predictive of a target token by maximizing the log likelihood of predicting this token (Dai & Le, 2015; Howard & Ruder, 2018; Radford et al., 2018; 2019). In a vanilla language modeling objective, the target token is always the next token that follows the context. Peters et al. (2018) propose an improvement by adding a reverse objective that also predicts the word token that precedes the context. Following this trend, current state-of-the-art encoders such as BERT (Devlin et al., 2018) and XLNet (Yang et al., 2019) are also trained with variants of the language modeling objective: masked language modeling and permutation language modeling. In this paper, we provide an alternative view and show that these methods also maximize a lower bound on the mutual information between different parts of a word sequence. Such a framework is inspired by the InfoMax principle (Linsker, 1988) and has been the main driver of progress in self-supervised representation learning in other domains such as computer vision, audio processing, and supervised learning (Belghazi et al., 2018; van den Oord et al., 2019; Hjelm et al., 2019; 1 9102 voN 62 ]LC.sc[ 2v05380.0191:viXra
Bachman et al., 2019; O’Connor & Veeling, 2019). Many of these methods are trained to maximize a particular lower bound called InfoNCE (van den Oord et al., 2019)—also known as contrastive learning (Arora et al., 2019). The main idea behind contrastive learning is to divide an input data into multiple (possibly overlapping) views and maximize the mutual information between encoded representations of these views, using views derived from other inputs as negative samples. In §2, we provide an overview of representation learning with mutual information maximization. We then show how the skip-gram objective (§3.1; Mikolov et al. 2013), masked language modeling (§3.2; Devlin et al. 2018), and permutation language modeling (§3.3; Yang et al. 2019), fit in this framework. In addition to providing a principled theoretical understanding that bridges progress in multiple areas, our proposed framework also gives rise to a general class of word representation learning models which serves as a basis for designing and combining self-supervised training objectives to create better language representations. As an example, we show how to use this framework to construct a simple self-supervised objective that maximizes the mutual information between a sentence and n-grams in the sentence (§4). We combine it with a variant of the masked language modeling objective and show that the resulting representation performs better, particularly on tasks such as question answering and linguistics acceptability (§5). 2 MUTUAL INFORMATION MAXIMIZATION Mutual information measures dependencies between random variables. Given two random variables A and B, it can be understood as how much knowing A reduces the uncertainty in B or vice versa. Formally, the mutual information between A and B is: I(A, B) = H(A) − H(A | B) = H(B) − H(B | A). Consider A and B to be different views of an input data (e.g., a word and its context, two different partitions of a sentence). Consider a function f that takes A = a and B = b as its input. The goal of training is to learn parameters of the function f that maximizes I(A, B). Maximizing mutual information directly is generally intractable when the function f consists of modern encoders such as neural networks (Paninski, 2003), so we need to resort to a lower bound on I(A, B). One particular lower bound that has been shown to work well in practice is InfoNCE (Logeswaran & Lee, 2018; van den Oord et al., 2019),1 which is based on Noise Contrastive Estimation (NCE; Gutmann & Hyvarinen, 2012).2 InfoNCE is defined as:    I(A, B) ≥ E p(A,B) f θ(a, b) − E q(B˜ ) log (cid:88) exp f θ(a, ˜b) + log | B˜ |, (1) ˜b∈B˜ where a and b are different views of an input sequence, f ∈ R is a function parameterized by θ θ (e.g., a dot product between encoded representations of a word and its context, a dot product between encoded representations of two partitions of a sentence), and B˜ is a set of samples drawn from a proposal distribution q(B˜ ). The set B˜ contains the positive sample b and |B˜ | − 1 negative samples. Learning representations based on this objective is also known as contrastive learning. Arora et al. (2019) show representations learned by such a method have provable performance guarantees and reduce sample complexity on downstream tasks. We note that InfoNCE is related to cross-entropy. When B˜ always includes all possible values of the random variable B (i.e., B˜ = B) and they are uniformly distributed, maximizing InfoNCE is analogous to maximizing the standard cross-entropy loss:   E p(A,B) f θ(a, b) − log (cid:88) exp f θ(a, ˜b) . (2) ˜b∈B 1Alternative bounds include Donsker-Vardhan representation (Donsker & Varadhan, 1983) and Jensen- Shannon estimator (Nowozin et al., 2016), but we focus on InfoNCE here. 2 See van den Oord et al. (2019); Poole et al. (2019) for detailed derivations of InfoNCE as a bound on mutual information. 2
Eq. 2 above shows that InfoNCE is related to maximizing p (b | a), and it approximates the θ summation over elements in B (i.e., the partition function) by negative sampling. As a function of the negative samples, the InfoNCE bound is tighter when B˜ contains more samples (as can be seen in Eq. 1 above by inspecting the log |B˜ | term). Approximating a softmax over a large vocabulary with negative samples is a popular technique that has been widely used in computer vision in the past. We discuss it here to make the connection under this framework clear. 3 MODELS We describe how Skip-gram, BERT, and XLNet fit into the mutual information maximization framework as instances of InfoNCE. In the following, we assume that f (a, b) = g (b)(cid:62)g (a), θ ψ ω where θ = {ω, ψ}. Denote the vocabulary set by V and the size of the vocabulary by V . For word representation learning, we seek to learn an encoder parameterized by ω to represent each word in a sequence x = {x , x , . . . , x } in d dimensions. For each of the models we consider in this paper, a 1 1 T and b are formed by taking different parts of x (e.g., a := x and b := x ). 0 T 3.1 SKIP-GRAM We first start with a simple word representation learning model Skip-gram (Mikolov et al., 2013). Skip-gram is a method for learning word representations that relies on the assumption that a good representation of a word should be predictive of its context. The objective function that is maximized in Skip-gram is: E (cid:2) p(xi | x )(cid:3) , where x is a word token and xi is a context word of x . p(xi,xi j) j i i j i Let b be the context word to be predicted xi and a be the input word x . Recall that f (a, b) is j i θ g (b)(cid:62)g (a). The skip-gram objective function can be written as an instance of InfoNCE (Eq. 1) ψ ω where g (b) and g (a) are embedding lookup functions that map each word type to Rd. (i.e., ψ ω g (b), g (a) : V → Rd). ψ ω p(xi | x ) can either be computed using a standard softmax over the entire vocabulary or with j i negative sampling (when the vocabulary is very large). These two approaches correspond to different choices of B˜ . In the softmax approach, B˜ is the full vocabulary set V and each word in V is uniformly distributed. In negative sampling, B˜ is a set of negative samples drawn from e.g., a unigram distribution. While Skip-gram has been widely accepted as an instance contrastive learning (Mikolov et al., 2013; Mnih & Kavukcuoglu, 2013), we include it here to illustrate its connection with modern approaches such as BERT and XLNet described subsequently. We can see that the two views of an input sentence that are considered in Skip-gram are two words that appear in the same sentence, and they are encoded using simple lookup functions. 3.2 BERT Devlin et al. (2018) introduce two self-supervised tasks for learning contextual word representations: masked language modeling and next sentence prediction. Previous work suggests that the next sentence prediction objective is not necessary to train a high quality BERT encoder and the masked language modeling appears to be the key to learn good representations (Liu et al., 2019; Joshi et al., 2019; Lample & Conneau, 2019), so we focus on masked language modeling here. However, we also show how next sentence prediction fits into our framework in Appendix A. In masked language modeling, given a sequence of word tokens of length T , x = {x , . . . , x }, 1 T BERT replaces 15% of the tokens in the sequence with (i) a mask symbol 80% of the time, (ii) a random word 10% of the time, or (iii) its original word. For each replaced token, it introduces a term in the masked language modeling training objective to predict the original word given the perturbed sequence xˆ = {x , . . . , xˆ , . . . , x } (i.e., the sequence x masked at x ). This training objective can i 1 i T i be written as: E [p(x | xˆ )]. p(xi,xˆi) i i 3
Following our notation in §2, we have f (a, b) = g (b)(cid:62)g (a). Let b be a masked word x and θ ψ ω i a be the masked sequence xˆ . Consider a Transformer encoder parameterized by ω and denote i g (xˆ ) ∈ Rd as a function that returns the final hidden state corresponding to the i-th token (i.e., the ω i masked token) after running xˆ through the Transformer. Let g : V → Rd be a lookup function that i ψ maps each word type into a vector and B˜ = B be the full vocabulary set V. Under this formulation, the masked language modeling objective maximizes Eq. 1 and different choices of masking probabilities can be understood as manipulating the joint distributions p(a, b). In BERT, the two views of a sentence correspond to a masked word in the sentence and its masked context. Contextual vs. non-contextual. It is generally understood that the main difference between Skip- gram and BERT is that Skip-gram learns representations of word types (i.e., the representation for a word is always the same regardless of the context it appears in) and BERT learns representations of word tokens. We note that under our formulation for either Skip-gram or BERT, the encoder that we want to learn appears in g , and g is not used after training. We show that Skip-gram and BERT ω ψ maximizes a similar objective, and the main difference is in the choice of the encoder that forms g —a context dependent Transformer encoder that takes a sequence as its input for BERT and a ω simple word embedding lookup for Skip-gram. 3.3 XLNET Yang et al. (2019) propose a permutation language modeling objective to learn contextual word repre- sentations. This objective considers all possible factorization permutations of a joint distribution of a sentence. Given a sentence x = {x , . . . , x }, there are T ! ways to factorize its joint distribution.3 1 T Given a sentence x, denote a permutation by z ∈ Z. XLNet optimizes the objective function: (cid:34) (cid:34) T (cid:35)(cid:35) (cid:88) E E log p(xz | xz ) . p(x) p(z) t <t t=1 As a running example, consider a permutation order 3,1,5,2,4 for a sentence x , x , x , x , x . 1 2 3 4 5 Given the order, XLNet is only trained to predict the last S tokens in practice. For S = 1, the context sequence used for training is x , x , x , _, x , with x being the target word. 1 2 3 5 4 In addition to replacing the Transformer encoder with Transformer XL (Dai et al., 2019), a key architectural innovation of XLNet is the two-stream self-attention. In two-stream self attention, a shared encoder is used to compute two sets of hidden representations from one original sequence. They are called the query stream and the content stream. In the query stream, the input sequence is masked at the target position, whereas the content stream sees the word at the target position. Words at future positions for the permutation order under consideration are also masked in both streams. These masks are implemented as two attention mask matrices. During training, the final hidden representation for a target position from the query stream is used to predict the target word. Since there is only one set of encoder parameters for both streams, we show that we can arrive at the permutation language modeling objective from the masked language modeling objective with an architectural change in the encoder. Denote a hidden representation by hk, where t indexes t the position and k indexes the layer, and consider the training sequence x , x , x , _, x and the 1 2 3 5 permutation order 3,1,5,2,4. In BERT, we compute attention scores to obtain hk from hk−1 for t t every t (i.e., t = 1, . . . , T ), where h0 is the embedding for the mask symbol. In XLNet, the attention 4 scores for future words in the permutation order are masked to 0. For example, when we compute hk, 1 only the attention score from hk−1 is considered (since the permutation order is 3,1,5,2,4). For 3 hk, we use hk−1 and hk−1. XLNet does not require a mask symbol embedding since the attention 5 1 3 score from a masked token is always zeroed out with an attention mask (implemented as a matrix). As a result, we can consider XLNet training as masked language modeling with stochastic attention masks in the encoder. It is now straightforward to see that the permutation language modeling objective is an instance of Eq.1, where b is a target token x and a is a masked sequence xˆ = {x , . . . , xˆ , . . . , x }. Similar to i i 1 i T 3For example, we can factorize p(x) = p(x )p(x | x ) . . . , p(x | x , . . . , x ) = p(x )p(x | 1 2 1 T 1 T−1 T T−1 x ) . . . , p(x | x , . . . , x ), and many others. T 1 T 2 4
Table 1: Summary of methods as instances of contrastive learning. See text for details. Objective a b p(a, b) g g ω ψ Skip-gram word word word and its context lookup lookup MLM context masked word masked tokens probability Transformer lookup NSP sentence sentence (non-)consecutive sentences Transformer lookup XLNet context masked word factorization permutation TXL++ lookup DIM context masked n-grams sentence and its n-grams Transformer not used BERT, we have a Transformer encoder parameterized by ω and denote g (xˆ ) ∈ Rd as a function ω i that returns the final hidden state corresponding to the i-th token (i.e., the masked token) after running xˆ through the Transformer. Let g : V → Rd be a lookup function that maps each word type into i ψ a vector and B˜ = B be the full vocabulary set V. The main difference between BERT and XLNet is that the encoder that forms g used in XLNet implements attention masking based on a sampled ω permutation order when building its representations. In addition, XLNet and BERT also differ in the choice of p(a, b) since each of them has its own masking procedure. However, we can see that both XLNet and BERT maximize the same objective. 4 INFOWORD Our analysis on Skip-Gram, BERT, and XLNet shows that their objective functions are different instances of InfoNCE in Eq.1, although they are typically trained using the entire vocabulary set for B˜ instead of negative sampling. These methods differ in how they choose which views of a sentence they use as a and b, the data distribution p(a, b), and the architecture of the encoder for computing g , ω which we summarize in Table 1. Seen under this unifying framework, we can observe that progress in the field has largely been driven by using a more powerful encoder to represent g . While we ω only provide derivations for Skip-gram, BERT, and XLNet, it is straightforward to show that other language-modeling-based pretraining-objectives such as those used in ELMo (Peters et al., 2018) and GPT-2 (Radford et al., 2019) can be formulated under this framework. Our framework also allows us to draw connections to other mutual information maximization representation learning methods that have been successful in other domains (e.g., computer vision, audio processing, supervised learning). In this section, we discuss an example derive insights to design a simple self-supervised objective for learning better language representations. Deep InfoMax (DIM; Hjelm et al., 2019) is a mutual information maximization based representation learning method for images. DIM shows that maximizing the mutual information between an image representation and local regions of the image improves the quality of the representation. The complete objective function that DIM maximizes consists of multiple terms. Here, we focus on a term in the objective that maximizes the mutual information between local features and global features. We describe the main idea of this objective for learning representations from a one-dimensional sequence, although it is originally proposed to learn from a two-dimensional object. Given a sequence x = {x , x , . . . , x }, we consider the “global” representation of the sequence 1 2 T to be the hidden state of the first token (assumed to be a special start of sentence symbol) after contextually encoding the sequence g (x),4 and the local representations to be the encoded repre- ω sentations of each word in the sequence g (x ). We can use the contrastive learning framework to ψ t design a task that maximizes the mutual information between this global representation vector and its corresponding “local” representations using local representations from other sequences g (xˆ ) ψ t as negative samples. This is analogous to training the global representation vector of a sentence to choose which words appear in the sentence and which words are from other sentences.5 However, if we feed the original sequence x to the encoder and take the hidden state of the first token as the global 4Alternatively, the global representation can be the averaged representations of words in the sequence although we do not explore this in our experiments. 5 We can see that this self-supervised task is related to the next sentence prediction objective in BERT. However, instead of learning a global representation (assumed to be the representation of the first token in BERT) 5
representation, the task becomes trivial since the global representation is built using all the words in the sequence. We instead use a masked sequence a := xˆ = {x , . . . , xˆ , . . . , x } and b := x . t 1 t T t State-of-the-art methods based on language modeling objectives consider all negative samples since the second view of the input data (i.e., the part denoted by b in Eq. 1) that are used is simple and it consists of only a target word—hence the size of the negative set is still manageable. A major benefit of the contrastive learning framework is that we only need to be able to take negative samples for training. Instead of individual words, we can use n-grams as the local representations.6 Denote an n-gram by x and a masked sequence masked at position i to j by xˆ We define I as: i:j i:j DIM   (cid:88) I DIM = E p(xˆi:j,xi:j) g ω(xˆ i:j)(cid:62)g ω(x i:j) − log exp(g ω(xˆ i:j)(cid:62)g ω(x˜ i:j)) , x˜i:j∈S˜ where xˆ is a sentence masked at position i to j, x is an n-gram spanning from i to j, and x˜ i:j i:j i:j is an n-gram from a set S˜ that consists of the positive sample x and negative n-grams from other i:j sentences in the corpus. We use one Transformer to encode both views, so we do not need g here. ψ Since the main goal of representation learning is to train an encoder parameterized by ω, it is possible to combine multiple self-supervised tasks into an objective function in the contrastive learning framework. Our model, which we denote INFOWORD, combines the above objective—which is designed to improve sentence and span representations—with a masked language modeling objective I for learning word representations. The only difference between our masked language modeling MLM objective and the standard masked language modeling objective is that we use negative sampling to construct V˜ by sampling from the unigram distribution. We have:   (cid:88) I MLM = E p(xˆi,xi) g ω(xˆ i)(cid:62)g ψ(x i) − log exp(g ω(xˆ i)(cid:62)g ψ(x˜ i)) , x˜i∈V˜ where xˆ a sentence masked at position i and x is the i-th token in the sentence. i i Our overall objective function is a weighted combination of the two terms above: I = λ I + λ I , INFOWORD MLM MLM DIM DIM where λ and λ are hyperparameters that balance the contribution of each term. MLM DIM 5 EXPERIMENTS In this section, we evaluate the effects of training masked language modeling with negative sampling and adding I to the quality of learned representations. DIM 5.1 SETUP We largely follow the same experimental setup as the original BERT model (Devlin et al., 2018). We have two Transformer architectures similar to BERT and BERT . BERT has 12 hidden BASE LARGE BASE layers, 768 hidden dimensions, and 12 attention heads (110 million parameters); whereas BERT LARGE has 24 hidden layers, 1024 hidden dimensions, and 16 attention heads (340 million parameters). For each of the Transformer variant above, we compare three models in our experiments: • BERT: The original BERT model publicly available in https://github.com/ google-research/bert. • BERT-NCE: Our reimplementation of BERT. It differs from the original implementation in several ways: (1) we only use the masked language modeling objective and remove next sentence prediction, (2) we use negative sampling instead of softmax, and (3) we only use one sentence for each training example in a batch. to be predictive of whether two sentences are consecutive sentences, it learns its global representation to be predictive of words in the original sentence. 6Local image patches used in DIM are analogous to n-grams in a sentence. 6
• INFOWORD: Our model described in §4. The main difference between INFOWORD and BERT-NCE is the addition of I to the objective function. We discuss how we mask the DIM data for I in §5.2. DIM 5.2 PRETRAINING We use the same training corpora and apply the same preprocessing and tokenization as BERT. We create masked sequences for training with I as follows. We iteratively sample n-grams from a DIM sequence until the masking budget (15% of the sequence length) has been spent. At each sampling iteration, we first sample the length of the n-gram (i.e., n in n-grams) from a Gaussian distribution N(5, 1) clipped at 1 (minimum length) and 10 (maximum length). Since BERT tokenizes words into subwords, we measure the n-gram length at the word level and compute the masking budget at the subword level. This procedure is inspired by the masking approach in Joshi et al. (2019). For negative sampling, we use words and n-grams from other sequences in the same batch as negative samples (for MLM and DIM respectively). There are approximately 70,000 subwords and 10,000 n-grams (words and phrases) in a batch. We discuss hyperparameter details in Appendix B. 5.3 FINE-TUNING We evaluate on two benchmarks: GLUE (Wang et al., 2019) and SQuAD(Rajpurkar et al., 2016). We train a task-specific decoder and fine-tune pretrained models for each dataset that we consider. We describe hyperparameter details in Appendix B. GLUE is a set of natural language understanding tasks that includes sentiment analysis, linguistic acceptability, paraphrasing, and natural language inference. Each task is formulated as a classification task. The tasks in GLUE are either a single-sentence classification task or a sentence pair classification task. We follow the same setup as the original BERT model and add a start of sentence symbol (i.e., the CLS symbol) to every example and use a separator symbol (i.e., the SEP symbol) to separate two concatenated sentences (for sentence pair classification tasks). We add a linear transformation and a softmax layer to predict the correct label (class) from the representation of the first token of the sequence. SQuAD is a reading comprehension dataset constructed from Wikipedia articles. We report results on SQuAD 1.1. Here, we also follow the same setup as the original BERT model and predict an answer span—the start and end indices of the correct answer in the context. We use a standard span predictor as the decoder, which we describe in details in Appendix C. 5.4 RESULTS We show our main results in Table 2 and Table 3. Our BERT reimplementation with negative sampling underperforms the original BERT model on GLUE but is significantly better on SQuAD. However, we think that the main reasons for this performance discrepancy are the different masking procedures (we use span-based masking instead of whole-word masking) and the different ways training examples are presented to the model (we use one consecutive sequence instead of two sequences separated by the separator symbol). Comparing BERT-NCE and INFOWORD, we observe the benefit of the new self-supervised objective I (better overall GLUE and SQuAD results), particularly on tasks such as DIM question answering and linguistics acceptability that seem to require understanding of longer phrases. In order to better understand our model, we investigate its performance with varying numbers of training examples and different values of λ on the SQuAD development set and show the results DIM in Figure 1 (for models with the BASE configuration). We can see that INFOWORD consistently outperforms BERT-NCE and the performance gap is biggest when the dataset is smallest, suggesting the benefit of having better pretrained representations when there are fewer training examples. 7
Table 2: Summary of results on GLUE. MNLI GLUE Model COLA SST-2 MRPC QQP QNLI RTE (M/MM) AVG B ESA BERT 52.1 93.5 88.9 71.2 84.6/83.4 90.5 66.4 78.8 BERT-NCE 50.8 93.0 88.6 70.5 83.2/83.0 90.9 65.9 78.2 INFOWORD 53.3 92.5 88.7 71.0 83.7/82.4 91.4 68.3 78.9 L EGRA BERT 60.5 94.9 89.3 72.1 86.7/85.9 92.7 70.1 81.5 BERT-NCE 54.7 93.1 89.5 71.2 85.8/85.0 92.7 72.5 80.6 INFOWORD 57.5 94.2 90.2 71.3 85.8/84.8 92.6 72.0 81.1 Table 3: Summary of results on SQuAD 1.1. DEV TEST Model F EM F EM 1 1 B ESA BERT 88.5 80.8 - - BERT-NCE 90.2 83.3 90.9 84.4 INFOWORD 90.7 84.0 91.4 84.7 L EGRA BERT 90.9 84.1 91.3 84.3 BERT-NCE 92.0 85.9 92.7 86.6 INFOWORD 92.6 86.6 93.1 87.3 5.5 DISCUSSION Span-based models. We show how to design a simple self-supervised task in the InfoNCE frame- work that improves downstream performance on several datasets. Learning language representations to predict contiguous masked tokens has been explored in other context, and the objective introduced in I is related to these span-based models such as SpanBERT (Joshi et al., 2019) and MASS (Song DIM et al., 2019). While our experimental goal is to demonstrate the benefit of contrastive learning for constructing self-supervised tasks, we note that INFOWORD is simpler to train and exhibits similar trends to SpanBERT that outperforms baseline models. We leave exhaustive comparisons to these methods to future work. Mutual information maximization. A recent study has questioned whether the success of In- foNCE as an objective function is due to its property as a lower bound on mutual information and provides an alternative hypothesis based on metric learning (Tschannen et al., 2019). Regardless of the prevailing perspective, InfoNCE is widely accepted as a good representation learning objective, and formulating state-of-the-art language representation learning methods under this framework offers valuable insights that unifies many popular representation learning methods. Regularization. Image representation learning methods often incorporate a regularization term in its objective function to encourage learned representations to look like a prior distribution (Hjelm et al., 2019; Bachman et al., 2019). This is useful for incorporating prior knowledge into a repre- sentation learning model. For example, the DeepInfoMax model has a term in its objective that encourages the learned representation from the encoder to match a uniform prior. Regularization is not commonly used when learning language representations. Our analysis and the connection we draw to representation learning methods used in other domains provide an insight into possible ways to incorporate prior knowledge into language representation learning models. Future directions. The InfoNCE framework provides a holistic way to view progress in language representation learning. The framework is very flexible and suggests several directions that can be explored to improve existing methods. We show that progress in the field has been largely driven by innovations in the encoder which forms g . InfoNCE is based on maximizing the mutual information ω between different views of an input data, and it facilitates training on structured views as long as we can perform negative sampling (van den Oord et al., 2019; Bachman et al., 2019). Our analysis demonstrates that existing methods based on language modeling objectives only consider a single target word as one of the views. We think that incorporating more complex views (e.g., higher-order or skip n-grams, syntactic and semantic parses, etc.) and designing appropriate self-supervised tasks 8
0 5 20 40 60 80 100 09 58 08 57 07 % of training examples F 1 BERT-NCE InfoWord 0.0 0.2 0.4 0.6 0.8 1.0 8.09 6.09 4.09 2.09 0.09 λDIM F 1 Figure 1: The left plot shows F 1 scores of BERT-NCE and INFOWORD as we increase the percentage of training examples on SQuAD (dev). The right plot shows F 1 scores of INFOWORD on SQuAD (dev) as a function of λ . DIM is a promising future direction. A related area that is also underexplored is designing methods to obtain better negative samples. 6 CONCLUSION We analyzed state-of-the-art language representation learning methods from the perspective of mutual information maximization. We provided a unifying view of classical and modern word embedding models and showed how they relate to popular representation learning methods used in other domains. We used this framework to construct a new self-supervised task based on maximizing the mutual information between the global representation and local representations of a sentence. We demonstrated the benefit of this new task via experiments on GLUE and SQuAD. REFERENCES Sanjeev Arora, Hrishikesh Khandeparkar, Mikhail Khodak, Orestis Plevrakis, and Nikunj Saunshi. A theoretical analysis of contrastive unsupervised representation learning. In Proc. of ICML, 2019. Philip Bachman, R Devon Hjelm, and William Buchwalter. Learning representations by maximizing mutual information across views. arXiv preprint 1906.00910, 2019. Mohamed Ishmael Belghazi, Aristide Baratin, Sai Rajeswar, Sherjil Ozair, Yoshua Bengio, Aaron Courville, and R Devon Hjelm. Mine: Mutual information neural estimation. In Proc. of ICML, 2018. Andrew M. Dai and Quoc V. Le. Semi-supervised sequence learning. In Proc. of NIPS, 2015. Zihang Dai, Zhilin Yang, Yiming Yang, Jaime Carbonell, Quoc V. Le, and Ruslan Salakhutdinov. Transformer-XL: Attentive language models beyond a fixed-length context. In Proc. of ACL, 2019. Jacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. BERT: Pre-training of deep bidirectional transformers for language understanding. In Proc. of NAACL, 2018. M. D. Donsker and S. R. S. Varadhan. Asymptotic evaluation of certain markov process expectations for large time. iv. Communications on Pure and Applied Mathematics, 36(2):183––212, 1983. Michael U. Gutmann and Aapo Hyvarinen. Noise-contrastive estimation of unnormalized statistical models, with applications to natural image statistics. Journal of Machine Learning Research, 13: 307––361, 2012. R Devon Hjelm, Alex Fedorov, Samuel Lavoie-Marchildon, Karan Grewal, Phil Bachman, Adam Trischler, and Yoshua Bengio. Learning deep representations by mutual information estimation and maximization. In Proc. of ICLR, 2019. Jeremy Howard and Sebastian Ruder. Universal language model fine-tuning for text classification. In Proc. of ACL, 2018. 9
Mandar Joshi, Danqi Chen, Yinhan Liu, Daniel S. Weld, Luke Zettlemoyer, and Omer Levy. Span- BERT: Improving pre-training by representing and predicting spans. arXiv preprint 1907.10529, 2019. Diederik P. Kingma and Jimmy Lei Ba. Adam: a method for stochastic optimization. In Proc. of ICLR, 2015. Guillaume Lample and Alexis Conneau. Cross-lingual language model pretraining. arXiv preprint 1901.07291, 2019. Ralph Linsker. Self-organization in a perceptual network. Computer, 21(3):105–117, 1988. Yinhan Liu, Myle Ott, Naman Goyal, Jingfei Du, Mandar Joshi, Danqi Chen, Omer Levy, Mike Lewis, Luke Zettlemoyer, and Veselin Stoyanov. RoBERTa: A robustly optimized bert pretraining approach. arXiv preprint 1907.11692, 2019. Lajanugen Logeswaran and Honglak Lee. An efficient framework for learning sentence representa- tions. In Proc. of ICLR, 2018. Tomas Mikolov, Ilya Sutskever, Kai Chen, Greg Corrado, and Jeffrey Dean. Distributed representa- tions of words and phrases and their compositionality. In Proc. of NIPS, 2013. Andriy Mnih and Koray Kavukcuoglu. Learning word embeddings efficiently with noise-contrastive estimation. In Proc. of NIPS, 2013. Sebastian Nowozin, Botond Cseke, , and Ryota Tomioka. f-gan: Training generative neural samplers using variational divergence minimization. In Proc. of NIPS, 2016. Sindy Lowe Peter O’Connor and Bastiaan S. Veeling. Greedy infomax for biologically plausible self-supervised representation learning. In Proc. of NeurIPS, 2019. Liam Paninski. Estimation of entropy and mutual information. Neural computation, 15(6):1191—- 1253, 2003. Jeffrey Pennington, Richard Socher, and Christopher D. Manning. Glove: Global vectors for word representation. In Proc. of EMNLP, 2014. Matthew E. Peters, Mark Neumann, Mohit Iyyer, Matt Gardner, Christopher Clark, Kenton Lee, and Luke Zettlemoyer. Deep contextualized word representations. In Proc. of NAACL, 2018. Ben Poole, Sherjil Ozair, Aaron van den Oord, Alexander A. Alemi, and George Tucker. On variational lower bounds of mutual information. In Proc. of ICML, 2019. Alec Radford, Karthik Narasimhan, Tim Salimans, and Ilya Sutskever. Improving language under- standing by generative pre-training. Technical report, OpenAI, 2018. Alec Radford, Jeffrey Wu, Rewon Child, David Luan, Dario Amodei, and Ilya Sutskever. Language models are unsupervised multitask learners. Technical report, OpenAI, 2019. Pranav Rajpurkar, Jian Zhang, Konstantin Lopyrev, and Percy Liang. SQuAD: 100,000+ questions for machine comprehension of text. In Proc. of EMNLP, 2016. Pranav Rajpurkar, Robin Jia, and Percy Liang. Know what you don’t know: Unanswerable questions for squad. In Proc. of ACL, 2018. Kaitao Song, Xu Tan, Tao Qin, Jianfeng Lu, and Tie-Yan Liu. MASS: Masked sequence to sequence pre-training for language generation. In Proc. of ICML, 2019. Michael Tschannen, Josip Djolonga, Paul K. Rubenstein, and Sylvain Gelly. On mutual information maximization for representation learning. arXiv preprint 1907.13625, 2019. Aaron van den Oord, Yazhe Li, and Oriol Vinyals. Representation learning with contrastive predictive coding. arXiv preprint 1807.03748, 2019. 10
Alex Wang, Amanpreet Singh, Julian Michael, Felix Hill, Omer Levy, and Samuel R. Bowman. GLUE: A multi-task benchmark and analysis platform for natural language understainding. In Proc. of ICLR, 2019. Zhilin Yang, Zihang Dai, Yiming Yang, Jaime Carbonell, Ruslan Salakhutdinov, and Quoc V. Le. XLNet: Generalized autoregressive pretraining for language understanding. arXiv preprint 1906.08237, 2019. Dani Yogatama, Cyprien de Masson d’Autume, Jerome Connor, Tomas Kocisky, Mike Chrzanowski, Lingpeng Kong, Angeliki Lazaridou, Wang Ling, Lei Yu, Chris Dyer, and Phil Blunsom. Learning and evaluating general linguistic intelligence. arXiv preprint 1901.11373, 2019. A NEXT SENTENCE PREDICTION We show that the next sentence prediction objective used in BERT is an instance of contrastive learning in this section. In next sentence prediction, given two sentences x1 and x2, the task is to predict whether these are two consecutive sentences or not. Training data for this task is created by sampling a random second sentence xˆ2 from the corpus to be used as a negative example 50% of the time. Consider a discriminator (i.e., a classifier with parameters φ) that takes encoded representations of concatenated x1 and x2 and returns a score. We denote this discriminator by d (x1, x2). The next φ sentence prediction objective function is: E (cid:2) log d (g ([x1, x2)]) + log(1 − d (g ([x1, x˜2])))(cid:3) . p(x1,x2) φ ω φ ω This objective function—which is used for training BERT—is known in the literature as “local” Noise Contrastive Estimation (Gutmann & Hyvarinen, 2012). Since summing over all possible negative sentences is intractable, BERT approximates this by using a binary classifier to distinguish real samples and noisy samples. An alternative approximation to using a binary classifier is to use “global NCE”, which is what InfoNCE is based on. Here, we have:   (cid:88) E p(x1,x2) ψ(cid:62)g ω([x1, x2)]) − log exp(ψ(cid:62)(g ω([x1, x˜2]))) , x˜2∈X˜ 2 where we sample negative sentences from the corpus and combine it with the positive sentence to construct X˜ 2. To make the connection of this objective function with InfoNCE in Eq. 1 explicit, let a and b be two consecutive sentences x and x . Let f (a, b) be ψ(cid:62)g ([a, b]), where ψ ∈ Rd is 1 2 θ ω a trainable parameter, [a, b] denotes a concatenation of a and b. Consider a Transformer encoder parameterized by ω, and let g ([a, b]) ∈ Rd be a function that returns the final hidden state of the ω first token after running the concatenated sequence to the Transformer. Note that the encoder that we want to learn only depends on g , so both of these approximations can be used for training next ω sentence prediction. B HYPERPARAMETERS Pretraining. We use Adam (Kingma & Ba, 2015) with β = 0.9, β = 0.98 and (cid:15) = 1e − 6. The 1 2 batch size for training is 1024 with a maximum sequence length of 512. We train for 400,000 steps (including 18,000 warmup steps) with a weight decay rate of 0.01. We set the learning rate to 4e−4 for all variants of the BASE models and 1e−4 for the LARGE models. We set λ MLM to 1.0 and tune λ ∈ {0.4, 0.6, 0.8, 1.0}. DIM GLUE. We set the maximum sequence length to 128. For each GLUE task, we use the respective development set to choose the learning rate from {5e−6, 1e−5, 2e−5, 3e−5, 5e−5}, and the batch size from {16, 32}. The number of training epochs is set to 4 for CoLA and 10 for other tasks, following Joshi et al. (2019). We run each hyperparameter configuration 5 times and evaluate the best model on the test set (once). 11
SQuAD. We set the maximum sequence length to 512 and train for 4 epochs. We use the develop- ment set to choose the learning rate from {5e−6, 1e−5, 2e−5, 3e−5, 5e−5} and the batch size from {16, 32}. C QUESTION ANSWERING DECODER We use a standard span predictor as follows. Denote the length of the context paragraph by M , and xcontext = {xcontext, . . . , xcontext}. Denote the encoded representation of the m-th token in 1 M the context by xcontext. The question answering decoder introduces two sets of parameters: w t,m start and w . The probability of each context token being the start of the answer is computed as: end p(start = xcontext | x ) = exp(w s(cid:62) tartxc to ,n mtext) . The probability of the end index of the answer is t,m t (cid:80)M exp(w(cid:62) xcontext) n=0 start t,n computed analogously using w . The predicted answer is the span with the highest probability after end multiplying the start and end probabilities. 12
