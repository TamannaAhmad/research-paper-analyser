Large Scale Adversarial Representation Learning Jeff Donahue Karen Simonyan DeepMind DeepMind jeffdonahue@google.com simonyan@google.com Abstract Adversarially trained generative models (GANs) have recently achieved compelling image synthesis results. But despite early successes in using GANs for unsuper- vised representation learning, they have since been superseded by approaches based on self-supervision. In this work we show that progress in image generation quality translates to substantially improved representation learning performance. Our approach, BigBiGAN, builds upon the state-of-the-art BigGAN model, extending it to representation learning by adding an encoder and modifying the discriminator. We extensively evaluate the representation learning and generation capabilities of these BigBiGAN models, demonstrating that these generation-based models achieve the state of the art in unsupervised representation learning on MNIST, as well as in unconditional image generation. 1 Introduction In recent years we have seen rapid progress in generative models of visual data. While these models were previously confined to domains with single or few modes, simple structure, and low resolution, with advances in both modeling and hardware they have since gained the ability to convincingly generate complex, multimodal, high resolution image distributions [1, 17, 19]. Intuitively, the ability to generate data in a particular domain necessitates a high-level understanding of the semantics of said domain. This idea has long-standing appeal as raw data is both cheap – readily available in virtually infinite supply from sources like the Internet – and rich, with images comprising far more information than the class labels that typical discriminative machine learning models are trained to predict from them. Yet, while the progress in generative models has been undeniable, nagging questions persist: what semantics have these models learned, and how can they be leveraged for representation learning? The dream of generation as a means of true understanding from raw data alone has hardly been realized. Instead, the most successful approaches for unsupervised learning leverage techniques adopted from the field of supervised learning, a class of methods known as self-supervised learning [3, 38, 35, 8]. These approaches typically involve changing or holding back certain aspects of the data in some way, and training a model to predict or generate aspects of the missing information. For example, [37, 38] proposed colorization as a means of unsupervised learning, where a model is given a subset of the color channels in an input image, and trained to predict the missing channels. Generative models as a means of unsupervised learning offer an appealing alternative to self- supervised tasks in that they are trained to model the full data distribution without requiring any modification of the original data. One class of generative models that has been applied to rep- resentation learning is generative adversarial networks (GANs) [10]. The generator in the GAN framework is a feed-forward mapping from randomly sampled latent variables (also called “noise”) to generated data, with learning signal provided by a discriminator trained to distinguish between real and generated data samples, guiding the generator’s outputs to follow the data distribution. The adversarially learned inference (ALI) [7] or bidirectional GAN (BiGAN) [4] approaches were 9102 luJ 4 ]VC.sc[ 1v44520.7091:viXra
discriminator D x E zˆ encoderE xˆ G z Grotareneg data x ∼ P xˆ ∼ G(z) scores x x xˆ F s x loss J s xz (cid:80) (cid:96) zˆ z H s z zˆ ∼ E(x) z ∼ P z latents Figure 1: The structure of the BigBiGAN framework. The joint discriminator D is used to compute the loss (cid:96). Its inputs are data-latent pairs, either (x ∼ P , zˆ ∼ E(x)), sampled from the data x distribution P and encoder E outputs, or (xˆ ∼ G(z), z ∼ P ), sampled from the generator G outputs x z and the latent distribution P . The loss (cid:96) includes the unary data term s and the unary latent term s , z x z as well as the joint term s which ties the data and latent distributions. xz proposed as extensions to the GAN framework that augment the standard GAN with an encoder module mapping real data to latents, the inverse of the mapping learned by the generator. In the limit of an optimal discriminator, [4] showed that a deterministic BiGAN behaves like an autoencoder minimizing (cid:96) reconstruction costs; however, the shape of the reconstruction error 0 surface is dictated by a parametric discriminator, as opposed to simple pixel-level measures like the (cid:96) error. Since the discriminator is usually a powerful neural network, the hope is that it will induce 2 an error surface which emphasizes “semantic” errors in reconstructions, rather than low-level details. In [4] it was demonstrated that the encoder learned via the BiGAN or ALI framework is an effective means of visual representation learning on MNIST for downstream tasks. However, it used a DCGAN [28] style generator, incapable of producing high-quality images on this dataset, so the semantics the encoder could model were in turn quite limited. In this work we revisit this approach using BigGAN [1] as the generator, a modern model that appears capable of capturing many of the modes and much of the structure present in MNIST images. Our contributions are as follows: • We show that BigBiGAN (BiGAN with BigGAN generator) matches the state of the art in unsupervised representation learning on MNIST. • We propose a more stable version of the joint discriminator for BigBiGAN. • We perform a thorough empirical analysis and ablation study of model design choices. • We show that the representation learning objective also helps unconditional image generation, and demonstrate state-of-the-art results in unconditional MNIST generation. 2 BigBiGAN The BiGAN [4] or ALI [7] approaches were proposed as extensions of the GAN [10] framework which enable the learning of an encoder that can be employed as an inference model [7] or feature representation [4]. Given a distribution P of data x (e.g., images), and a distribution P of latents z x z (usually a simple continuous distribution like an isotropic Gaussian N (0, I)), the generator G models a conditional distribution P (x|z) of data x given latent inputs z sampled from the latent prior P , z as in the standard GAN generator [10]. The encoder E models the inverse conditional distribution P (z|x), predicting latents z given data x sampled from the data distribution P . x Besides the addition of E, the other modification to the GAN in the BiGAN framework is a joint discriminator D, which takes as input data-latent pairs (x, z) (rather than just data x as in a standard GAN), and learns to discriminate between pairs from the data distribution and encoder, versus 2
the generator and latent distribution. Concretely, its inputs are pairs (x ∼ P , zˆ ∼ E(x)) and x (xˆ ∼ G(z), z ∼ P ), and the goal of the G and E is to “fool” the discriminator by making the two z joint distributions P and P from which these pairs are sampled indistinguishable. The adversarial xE Gz minimax objective in [4, 7], analogous to that of the GAN framework [10], was defined as follows: min max (cid:8)E [log(σ(D(x, z)))] + E [log(1 − σ(D(x, z)))](cid:9) GE D x∼Px,z∼EΦ(x) z∼Pz,x∼GΦ(z) Under this objective, [4, 7] showed that with an optimal D, G and E minimize the Jensen-Shannon divergence between the joint distributions P and P , and therefore at the global optimum, the xE Gz two joint distributions P = P match, analogous to the results from standard GANs [10]. xE Gz Furthermore, [4] showed that in the case where E and G are deterministic functions (i.e., the learned conditional distributions P (x|z) and P (z|x) are Dirac δ functions), these two functions are inverses G E at the global optimum: e.g., ∀ x = G(E(x)), with the optimal joint discriminator effectively x∈supp(Px) imposing (cid:96) reconstruction costs on x and z. 0 While the crux of our approach, BigBiGAN, remains the same as that of BiGAN [4, 7], we have adopted the generator and discriminator architectures from the state-of-the-art BigGAN [1] generative image model. Beyond that, we have found that an improved discriminator structure leads to better representation learning results without compromising generation (Figure 1). Namely, in addition to the joint discriminator loss proposed in [4, 7] which ties the data and latent distributions together, we propose additional unary terms in the learning objective, which are functions only of either the data x or the latents z. Although [4, 7] prove that the original BiGAN objective already enforces that the learnt joint distributions match at the global optimum, implying that the marginal distributions of x and z match as well, these unary terms intuitively guide optimization in the “right direction” by explicitly enforcing this property. For example, in the context of image generation, the unary loss term on x matches the original GAN objective and provides a learning signal which steers only the generator to match the image distribution independently of its latent inputs. (In our evaluation we will demonstrate empirically that the addition of these terms results in both improved generation and representation learning.) Concretely, the discriminator loss L and the encoder-generator loss L are defined as follows, D EG based on scalar discriminator “score” functions s and the corresponding per-sample losses (cid:96) : ∗ ∗ (cid:124) s (x) = θ F (x) x x Θ (cid:124) s (z) = θ H (z) z z Θ (cid:124) s (x, z) = θ J (F (x), H (z)) xz xz Θ Θ Θ (cid:96) (x, z, y) = y (s (x) + s (z) + s (x, z)) y ∈ {−1, +1} EG x z xz L (P , P ) = E [(cid:96) (x, zˆ, +1)] + E [(cid:96) (xˆ, z, −1)] EG x z x∼Px,zˆ∼EΦ(x) EG z∼Pz,xˆ∼GΦ(z) EG (cid:96) (x, z, y) = h(ys (x)) + h(ys (z)) + h(ys (x, z)) y ∈ {−1, +1} D x z xz L (P , P ) = E [(cid:96) (x, zˆ, +1)] + E [(cid:96) (xˆ, z, −1)] D x z x∼Px,zˆ∼EΦ(x) D z∼Pz,xˆ∼GΦ(z) D where h(t) = max(0, 1 − t) is a “hinge” used to regularize the discriminator [23, 33] 1, also used in BigGAN [1]. The discriminator D includes three submodules: F , H, and J. F takes only x as input and H takes only z, and learned projections of their outputs with parameters θ and θ respectively x z give the scalar unary scores s and s . In our experiments, the data x are images and latents z are x z unstructured flat vectors; accordingly, F is a ConvNet and H is an MLP. The joint score s tying x xz and z is given by the remaining D submodule, J, a function of the outputs of F and H. The E and G parameters Φ are optimized to minimize the loss L , and the D parameters Θ are EG optimized to minimize loss L . As usual, the expectations E are estimated by Monte Carlo samples D taken over minibatches. 3 Evaluation Most of our experiments follow the standard protocol used to evaluate unsupervised learning tech- niques, first proposed in [37]. We train a BigBiGAN on unlabeled MNIST, freeze its learned 1 We also considered an alternative discriminator loss (cid:96)(cid:48) which invokes the “hinge” h just once on the D sum of the three loss terms – (cid:96)(cid:48) (x, z, y) = h(y (s (x) + s (z) + s (x, z))) – but found that this performed D x z xz significantly worse than (cid:96) above which clamps each of the three loss terms separately. D 3
representation, and then train a linear classifier on its outputs, fully supervised using all of the training set labels. We also measure image generation performance, reporting Inception Score [31] (IS) and Fréchet Inception Distance [15] (FID) as the standard metrics there. 3.1 Ablation We begin with an extensive ablation study in which we directly evaluate a number of modeling choices, with results presented in Table 1. Where possible we performed three runs of each variant with different seeds and report the mean and standard deviation for each metric. We start with a relatively fully-fledged version of the model at 128 × 128 resolution (row Base), with the G architecture and the F component of D taken from the corresponding 128 × 128 architectures in BigGAN, including the skip connections and shared noise embedding proposed in [1]. z is 120 dimensions, split into six groups of 20 dimensions fed into each of the six layers of G as in [1]. The remaining components of D – H and J – are 8-layer MLPs with ResNet-style skip connections (four residual blocks with two layers each) and size 2048 hidden layers. The E architecture is the ResNet-v2-50 ConvNet originally proposed for image classification in [13], followed by a 4-layer MLP (size 4096) with skip connections (two residual blocks) after ResNet’s globally average pooled output. The unconditional BigGAN training setup corresponds to the “Single Label” setup proposed in [24], where a single “dummy” label is used for all images (theoretically equivalent to learning a bias in place of the class-conditional batch norm inputs). We then ablate several aspects of the model, with results detailed in the following paragraphs. Additional architectural and optimization details are provided in Appendix A. Full learning curves for many results are included in Appendix D. Latent distribution P and stochastic E. As in ALI [7], the encoder E of our Base model is non- z deterministic, parametrizing a distribution N (µ, σ). µ and σˆ are given by a linear layer at the output of the model, and the final standard deviation σ is computed from σˆ using a non-negative “softplus” non-linearity σ = log(1 + exp(σˆ)) [6]. The final z uses the reparametrized sampling from [20], with z = µ + (cid:15)σ, where (cid:15) ∼ N (0, I). Compared to a deterministic encoder (row Deterministic E) which predicts z directly without sampling (effectively modeling P (z|x) as a Dirac δ distribution), the non-deterministic Base model achieves significantly better classification performance (at no cost to generation). We also compared to using a uniform P = U(−1, 1) (row Uniform P ) with E z z deterministically predicting z = tanh(zˆ) given a linear output zˆ, as done in BiGAN [4]. This also achieves worse classification results than the non-deterministic Base model. Unary loss terms. We evaluate the effect of removing one or both unary terms of the loss function proposed in Section 2, s and s . Removing both unary terms (row No Unaries) corresponds to the x z original objective proposed in [4, 7]. It is clear that the x unary term has a large positive effect on generation performance, with the Base and x Unary Only rows having significantly better IS and FID than the z Unary Only and No Unaries rows. This result makes intuitive sense as it matches the standard generator loss. It also marginally improves classification performance. The z unary term makes a more marginal difference, likely due to the relative ease of modeling relatively simple distributions like isotropic Gaussians, though also does result in slightly improved classification and generation in terms of FID – especially without the x term (z Unary Only vs. No Unaries). On the other hand, IS is worse with the z term. This may be due to IS roughly measuring the generator’s coverage of the major modes of the distribution (the classes) rather than the distribution in its entirety, the latter of which may be better captured by FID and more likely to be promoted by a good encoder E. The requirement of invertibility in a (Big)BiGAN could be encouraging the generator to produce distinguishable outputs across the entire latent space, rather than “collapsing” large volumes of latent space to a single mode of the data distribution. G capacity. To address the question of the importance of the generator G in representation learning, we vary the capacity of G (with E and D fixed) in the Small G rows. With a third of the capacity of the Base G model (Small G (32)), the overall model is quite unstable and achieves significantly worse classification results than the higher capacity base model2 With two-thirds capacity (Small G (64)), generation performance is substantially worse (matching the results in [1]) and classification 2Though the generation performance by IS and FID in row Small G (32) is very poor at the point we measured – when its best validation classification performance (43.59%) is achieved – this model was performing more reasonably for generation earlier in training, reaching IS 14.69 and FID 60.67. 4
performance is modestly worse. These results confirm that a powerful image generator is indeed important for learning good representations via the encoder. Assuming this relationship holds in the future, we expect that better generative models are likely to lead to further improvements in representation learning. Standard GAN. We also compare BigBiGAN’s image generation performance against a standard unconditional BigGAN with no encoder E and only the standard F ConvNet in the discriminator, with only the s term in the loss (row No E (GAN)). While the standard GAN achieves a marginally better x IS, the BigBiGAN FID is about the same, indicating that the addition of the BigBiGAN E and joint D does not compromise generation with the newly proposed unary loss terms described in Section 2. (In comparison, the versions of the model without unary loss term on x – rows z Unary Only and No Unaries – have substantially worse generation performance in terms of FID than the standard GAN.) We conjecture that the IS is worse for similar reasons that the s unary loss term leads to z worse IS. Next we will show that with an enhanced E taking higher input resolutions, generation with BigBiGAN in terms of FID is substantially improved over the standard GAN. High resolution E with varying resolution G. BiGAN [4] proposed an asymmetric setup in which E takes higher resolution images than G outputs and D takes as input, showing that an E taking 128 × 128 inputs with a 64 × 64 G outperforms a 64 × 64 E for downstream tasks. We experiment with this setup in BigBiGAN, raising the E input resolution to 256 × 256 – matching the resolution used in typical supervised MNIST classification setups – and varying the G output and D input resolution in {64, 128, 256}. Our results in Table 1 (rows High Res E (256) and Low/High Res G (*)) show that BigBiGAN achieves better representation learning results as the G resolution increases, up to the full E resolution of 256 × 256. However, because the overall model is much slower to train with G at 256 × 256 resolution, the remainder of our results use the 128 × 128 resolution for G. Interestingly, with the higher resolution E, generation improves significantly (especially by FID), despite G operating at the same resolution (row High Res E (256) vs. Base). This is an encouraging result for the potential of BigBiGAN as a means of improving adversarial image synthesis itself, besides its use in representation learning and inference. E architecture. Keeping the E input resolution fixed at 256, we experiment with varied and often larger E architectures, including several of the ResNet-50 variants explored in [21]. In particular, we expand the capacity of the hidden layers by a factor of 2 or 4, as well as swap the residual block structure to a reversible variant called RevNet [9] with the same number of layers and capacity as the corresponding ResNets. (We use the version of RevNet described in [21].) We find that the base ResNet-50 model (row High Res E (256)) outperforms RevNet-50 (row RevNet), but as the network widths are expanded, we begin to see improvements from RevNet-50, with double-width RevNet outperforming a ResNet of the same capacity (rows RevNet ×2 and ResNet ×2). We see further gains with an even larger quadruple-width RevNet model (row RevNet ×4), which we use for our final results in Section 3.2. Decoupled E/G optimization. As a final improvement, we decoupled the E optimizer from that of G, and found that simply using a 10× higher learning rate for E dramatically accelerates training and improves final representation learning results. For ResNet-50 this improves linear classifier F1-score by nearly 3% (ResNet (↑ E LR) vs. High Res E (256)). We also applied this to our largest E architecture, RevNet-50 ×4, and saw similar gains (RevNet ×4 (↑ E LR) vs. RevNet ×4). 3.2 Comparison with prior methods Representation learning. We now take our best model by train classification F1-score from the val above ablations and present results on the official MNIST validation set, comparing against the state of the art in recent unsupervised learning literature. For comparison, we also present classification results for our best performing variant with the smaller ResNet-50-based E. These models correspond to the last two rows of Table 1, ResNet (↑ E LR) and RevNet ×4 (↑ E LR). Results are presented in Table 2. (For reference, the fully supervised F1-score of these architectures is given in Appendix A, Table 4.) Compared with a number of modern self-supervised approaches [27, 2, 37, 35, 8, 14] and combinations thereof [3], our BigBiGAN approach based purely on generative models performs well for representation learning, state-of-the-art among recent unsupervised learning 5
Encoder (E) Gen. (G) Loss L∗ Results A. D. C. R. Var. η C. R. sxz sx sz Pz IS (↑) FID (↓) Cls. (↑) Base S 50 1 128 (cid:88) 1 96 128 (cid:88) (cid:88) (cid:88) N 22.66 ± 0.18 31.19 ± 0.37 48.10 ± 0.13 Deterministic E S 50 1 128 (-) 1 96 128 (cid:88) (cid:88) (cid:88) N 22.79 ± 0.27 31.31 ± 0.30 46.97 ± 0.35 Uniform Pz S 50 1 128 (-) 1 96 128 (cid:88) (cid:88) (cid:88) (U) 22.83 ± 0.24 31.52 ± 0.28 45.11 ± 0.93 x Unary Only S 50 1 128 (cid:88) 1 96 128 (cid:88) (cid:88) (-) N 23.19 ± 0.28 31.99 ± 0.30 47.74 ± 0.20 z Unary Only S 50 1 128 (cid:88) 1 96 128 (cid:88) (-) (cid:88) N 19.52 ± 0.39 39.48 ± 1.00 47.78 ± 0.28 No Unaries (BiGAN) S 50 1 128 (cid:88) 1 96 128 (cid:88) (-) (-) N 19.70 ± 0.30 42.92 ± 0.92 46.71 ± 0.88 Small G (32) S 50 1 128 (cid:88) 1 (32) 128 (cid:88) (cid:88) (cid:88) N 3.28 ± 0.18 247.30 ± 10.31 43.59 ± 0.34 Small G (64) S 50 1 128 (cid:88) 1 (64) 128 (cid:88) (cid:88) (cid:88) N 19.96 ± 0.15 38.93 ± 0.39 47.54 ± 0.33 No E (GAN) * (-) 96 128 (-) (cid:88) (-) N 23.56 ± 0.37 30.91 ± 0.23 - High Res E (256) S 50 1 (256) (cid:88) 1 96 128 (cid:88) (cid:88) (cid:88) N 23.45 ± 0.14 27.86 ± 0.13 50.80 ± 0.30 Low Res G (64) S 50 1 (256) (cid:88) 1 96 (64) (cid:88) (cid:88) (cid:88) N 19.40 ± 0.19 15.82 ± 0.06 47.51 ± 0.09 High Res G (256) S 50 1 (256) (cid:88) 1 96 (256) (cid:88) (cid:88) (cid:88) N 24.70 38.58 51.49 ResNet-101 S (101) 1 (256) (cid:88) 1 96 128 (cid:88) (cid:88) (cid:88) N 23.29 28.01 51.21 ResNet ×2 S 50 (2) (256) (cid:88) 1 96 128 (cid:88) (cid:88) (cid:88) N 23.68 27.81 52.66 RevNet (V) 50 1 (256) (cid:88) 1 96 128 (cid:88) (cid:88) (cid:88) N 23.33 ± 0.09 27.78 ± 0.06 49.42 ± 0.18 RevNet ×2 (V) 50 (2) (256) (cid:88) 1 96 128 (cid:88) (cid:88) (cid:88) N 23.21 27.96 54.40 RevNet ×4 (V) 50 (4) (256) (cid:88) 1 96 128 (cid:88) (cid:88) (cid:88) N 23.23 28.15 57.15 ResNet (↑ E LR) S 50 1 (256) (cid:88) (10) 96 128 (cid:88) (cid:88) (cid:88) N 23.27 ± 0.22 28.51 ± 0.44 53.70 ± 0.15 RevNet ×4 (↑ E LR) (V) 50 (4) (256) (cid:88) (10) 96 128 (cid:88) (cid:88) (cid:88) N 23.08 28.54 60.15 Table 1: Results for variants of BigBiGAN, given in Inception Score [31] (IS) and Fréchet Inception Distance [15] (FID) of the generated images, and MNIST top-1 classification F1-score percentage (Cls.) of a supervised logistic regression classifier trained on the encoder features [37], computed on a split of 10K images randomly sampled from the training set, which we refer to as the “train ” val split. The Encoder (E) columns specify the E architecture (A.) as ResNet (S) or RevNet (V), the depth (D., e.g. 50 for ResNet-50), the channel width multiplier (C.), with 1 denoting the original widths from [13], the input image resolution (R.), whether the variance is predicted and a z vector is sampled from the resulting distribution (Var.), and the learning rate multiplier η relative to the G learning rate. The Generator (G) columns specify the BigGAN G channel multiplier (C.), with 96 corresponding to the original width from [1], and output image resolution (R.). The Loss columns specify which terms of the BigBiGAN loss are present in the objective. The P column specifies the z input distribution as a standard normal N (0, 1) or continuous uniform U(−1, 1). Changes from the Base setup in each row are highlighted in blue. Results with margins of error (written as “µ ± σ”) are the means and standard deviations over three runs with different random seeds. (Experiments requiring more computation were run only once.) (* Result for vanilla GAN (No E (GAN)) selected with early stopping based on best FID; other results selected with early stopping based on validation classification F1-score (Cls.).) Method Architecture Feature Top-1 Top-5 BiGAN [4, 38] AlexNet conv3 31.0 - Motion Segmentation (MS) [27, 3] ResNet-101 AvePool 27.6 48.3 Exemplar (Ex) [5, 3] ResNet-101 AvePool 31.5 53.1 Relative Position (RP) [2, 3] ResNet-101 AvePool 36.2 59.2 Colorization (Col) [37, 3] ResNet-101 AvePool 39.6 62.5 Combination of MS+Ex+RP+Col [3] ResNet-101 AvePool - 69.3 CPC [35] ResNet-101 AvePool 48.7 73.6 Rotation [8, 21] RevNet-50 ×4 AvePool 55.4 - Efficient CPC [14] ResNet-170 AvePool 61.0 83.0 ResNet-50 AvePool 55.4 77.4 ResNet-50 BN+CReLU 56.6 78.6 BigBiGAN (ours) RevNet-50 ×4 AvePool 60.8 81.4 RevNet-50 ×4 BN+CReLU 61.3 81.9 Table 2: Comparison of BigBiGAN models on the official MNIST validation set against recent competing approaches with a supervised logistic regression classifier. BigBiGAN results are selected with early stopping based on highest F1-score on our train subset of 10K training set images. val ResNet-50 results correspond to row ResNet (↑ E LR) in Table 1, and RevNet-50 ×4 corresponds to RevNet ×4 (↑ E LR). 6
Method Steps IS (↑) FID vs. Train (↓) FID vs. Val. (↓) BigGAN + SL [24] 500K 20.4 (15.4 ± 7.57) - 25.3 (71.7 ± 66.32) BigGAN + Clustering [24] 500K 22.7 (22.8 ± 0.42) - 23.2 (22.7 ± 0.80) BigBiGAN + SL (ours) 500K 25.38 (25.33 ± 0.17) 22.78 (22.63 ± 0.23) 23.60 (23.56 ± 0.12) BigBiGAN High Res E + SL (ours) 500K 25.43 (25.45 ± 0.04) 22.34 (22.36 ± 0.04) 22.94 (23.00 ± 0.15) BigBiGAN High Res E + SL (ours) 1M 27.94 (27.80 ± 0.21) 20.32 (20.27 ± 0.09) 21.61 (21.62 ± 0.09) Table 3: Comparison of our BigBiGAN for unsupervised (unconditional) generation vs. previously reported results for unsupervised BigGAN from [24]. We specify the “pseudo-labeling” method as SL (Single Label) or Clustering. For comparison we train BigBiGAN for the same number of steps (500K) as the BigGAN-based approaches from [24], but also present results from additional training to 1M steps in the last row and observe further improvements. All results above include the median m as well as the mean µ and standard deviation σ across three runs, written as “m (µ ± σ)”. The BigBiGAN result is selected with early stopping based on best FID vs. Train. results, improving upon a recently published result from [21] of 55.4% to 60.8% top-1 F1-score using rotation prediction pre-training with the same representation learning architecture 3 and feature, labeled as AvePool in Table 2, and matches the results of the concurrent work in [14] based on contrastic predictive coding (CPC). We also experiment with learning linear classifiers on a different rendering of the AvePool feature, labeled BN+CReLU, which boosts our best results with RevNet ×4 to 61.3% top-1 F1-score. Given the global average pooling output a, we first compute h = BatchNorm(a), and the final feature is computed by concatenating [ReLU(h), ReLU(−h)], sometimes called a “CReLU” (concatened ReLU) non-linearity [32]. BatchNorm denotes parameter-free Batch Normalization [16], where the scale (γ) and offset (β) parameters are not learned, so training a linear classifier on this feature does not involve any additional learning. The CReLU non-linearity retains all the information in its inputs and doubles the feature dimension, each of which likely contributes to the improved results. Finally, in Appendix C we consider evaluating representations by zero-shot k nearest neighbors classification, achieving 43.3% top-1 F1-score in this setting. Qualitative examples of nearest neighbors are presented in Figure 12. Unsupervised image generation. In Table 3 we show results for unsupervised generation with BigBiGAN, comparing to the BigGAN-based [1] unsupervised generation results from [24]. Note that these results differ from those in Table 1 due to the use of the data augmentation method of [24]4 (rather than ResNet-style preprocessing used for all results in our Table 1 ablation study). The lighter augmentation from [24] results in better image generation performance under the IS and FID metrics. The improvements are likely due in part to the fact that this augmentation, on average, crops larger portions of the image, thus yielding generators that typically produce images encompassing most or all of a given object, which tends to result in more representative samples of any given class (giving better IS) and more closely matching the statistics of full center crops (as used in the real data statistics to compute FID). Besides this preprocessing difference, the approaches in Table 3 have the same configurations as used in the Base or High Res E (256) row of Table 1. These results show that BigBiGAN significantly improves both IS and FID over the baseline uncondi- tional BigGAN generation results with the same (unsupervised) “labels” (a single fixed label in the SL (Single Label) approach – row BigBiGAN + SL vs. BigGAN + SL). We see further improvements using a high resolution E (row BigBiGAN High Res E + SL), surpassing the previous unsupervised state of the art (row BigGAN + Clustering) under both IS and FID. (Note that the image generation results remain comparable: the generated image resolution is still 128 × 128 here, despite the higher resolution E input.) The alternative “pseudo-labeling” approach from [24], Clustering, which uses labels derived from unsupervised clustering, is complementary to BigBiGAN and combining both could yield further improvements. Finally, observing that results continue to improve significantly with training beyond 500K steps, we also report results at 1M steps in the final row of Table 3. 3Our RevNet ×4 architecture matches the widest architectures used in [21], labeled as ×16 there. 4See the “distorted” preprocessing method from the Compare GAN framework: https://github.com/ google/compare_gan/blob/master/compare_gan/datasets.py. 7
Figure 2: Selected reconstructions from an unsupervised BigBiGAN model (Section 3.3). Top row images are real data x ∼ P ; bottom row images are generated reconstructions of the above image x x computed by G(E(x)). Unlike most explicit reconstruction costs (e.g., pixel-wise), the reconstruction cost implicitly minimized by a (Big)BiGAN [4, 7] tends to emphasize more semantic, high-level details. Additional reconstructions are presented in Appendix B. 3.3 Reconstruction As shown in [4, 7], the (Big)BiGAN E and G can reconstruct data instances x by computing the encoder’s predicted latent representation E(x) and then passing this predicted latent back through the generator to obtain the reconstruction G(E(x)). We present BigBiGAN reconstructions in Figure 2. These reconstructions are far from pixel-perfect, likely due in part to the fact that no reconstruction cost is explicitly enforced by the objective – reconstructions are not even computed at training time. However, they may provide some intuition for what features the encoder E learns to model. For example, when the input image contains a dog, person, or a food item, the reconstruction is often a different instance of the same “category” with similar pose, position, and texture – for example, a similar species of dog facing the same direction. The extent to which these reconstructions tend to retain the high-level semantics of the inputs rather than the low-level details suggests that BigBiGAN training encourages the encoder to model the former more so than the latter. Additional reconstructions are presented in Appendix B. 4 Related work A number of approaches to unsupervised representation learning from images based on self- supervision have proven very successful. Self-supervision generally involves learning from tasks designed to resemble supervised learning in some way, but in which the “labels” can be created automatically from the data itself with no manual effort. An early example is relative location predic- tion [2], where a model is trained on input pairs of image patches and predicts their relative locations. Contrastive predictive coding (CPC) [35, 14] is a recent related approach where, given an image patch, a model predicts which patches occur in other image locations. Other approaches include colorization [37, 38], motion segmentation [27], rotation prediction [8], and exemplar matching [5]. Rigorous empirical comparisons of many of these approaches have also been conducted [3, 21]. A key advantage offered by BigBiGAN and other approaches based on generative models, relative to most self-supervised approaches, is that their input may be the full-resolution image or other signal, with no cropping or modification of the data needed (though such modifications may be beneficial as data augmentation). This means the resulting representation can typically be applied directly to full data in the downstream task with no domain shift. A number of relevant autoencoder and GAN variants have also been proposed. Associative com- pression networks (ACNs) [12] learn to compress at the dataset level by conditioning data on other previously transmitted data which are similar in code space, resulting in models that can “daydream” semantically similar samples, similar to BigBiGAN reconstructions. VQ-VAEs [36] pair a discrete (vector quantized) encoder with an autoregressive decoder to produce faithful reconstructions with a high compression factor and demonstrate representation learning results in supervised learning settings. In the adversarial space, adversarial autoencoders [25] proposed an autoencoder-style encoder-decoder pair trained with pixel-level reconstruction cost, replacing the KL-divergence reg- ularization of the prior used in VAEs [20] with a discriminator. In another proposed VAE-GAN hybrid [22] the pixel-space reconstruction error used in most VAEs is replaced with feature space 8
distance from an intermediate layer of a GAN discriminator. Other hybrid approaches like AGE [34] and α-GAN [29] add an encoder to stabilize GAN training. An interesting difference between many of these approaches and the BiGAN [7, 4] framework is that BiGAN does not train the encoder or generator with an explicit reconstruction cost. Though it can be shown that (Big)BiGAN implicitly minimizes a reconstruction cost, qualitative reconstruction results (Section 3.3) suggest that this reconstruction cost is of a different flavor, emphasizing high-level semantics over pixel-level details. 5 Discussion We have shown that BigBiGAN, an unsupervised learning approach based purely on generative mod- els, achieves state-of-the-art results in image representation learning on MNIST. Our ablation study lends further credence to the hope that powerful generative models can be beneficial for representation learning, and in turn that learning an inference model can improve large-scale generative models. In the future we hope that representation learning can continue to benefit from further advances in generative models and inference models alike, as well as scaling to larger image databases. Acknowledgments The authors would like to thank Aidan Clark, Olivier Hénaff, Aäron van den Oord, Sander Dieleman, and many other colleagues at DeepMind for useful discussions and feedback on this work. References [1] Andrew Brock, Jeff Donahue, and Karen Simonyan. Large scale GAN training for high fidelity natural image synthesis. In ICLR, 2019. [2] Carl Doersch, Abhinav Gupta, and Alexei A. Efros. Unsupervised visual representation learning by context prediction. In ICCV, 2015. [3] Carl Doersch and Andrew Zisserman. Multi-task self-supervised visual learning. In ICCV, 2017. [4] Jeff Donahue, Philipp Krähenbühl, and Trevor Darrell. Adversarial feature learning. In ICLR, 2017. [5] Alexey Dosovitskiy, Philipp Fischer, Jost Tobias Springenberg, Martin Riedmiller, and Thomas Brox. Discriminative unsupervised feature learning with exemplar convolutional neural networks. In NeurIPS, 2014. [6] Charles Dugas, Yoshua Bengio, François Belisle, Claude Nadeau, and Rene Garcia. Incorporating second-order functional knowledge for better option pricing. In NeurIPS, 2000. [7] Vincent Dumoulin, Ishmael Belghazi, Ben Poole, Olivier Mastropietro, Alex Lamb, Martin Arjovsky, and Aaron Courville. Adversarially learned inference. In ICLR, 2017. [8] Spyros Gidaris, Praveer Singh, and Nikos Komodakis. Unsupervised representation learning by predicting image rotations. In ICLR, 2018. [9] Aidan N. Gomez, Mengye Ren, Raquel Urtasun, and Roger B. Grosse. The reversible residual network: meta-optimization synthesis without storing activations. In NeurIPS, 2017. [10] Ian Goodfellow, Jean Pouget-Abadie, Mehdi Mirza, Bing Xu, David Warde-Farley, Sherjil Ozair, Aaron Courville, and Yoshua Bengio. Generative adversarial nets. In NeurIPS, 2014. [11] Google. Cloud TPU. https://cloud.google.com/tpu/. Accessed: 2019. [12] Alex Graves, Jacob Menick, and Aäron van den Oord. Associative compression networks. In arXiv:1804.02476, 2018. [13] Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Identity mappings in deep residual networks. In ECCV, 2016. [14] Olivier J. Hénaff, Ali Razavi, Carl Doersch, S. M. Ali Eslami, and Aäron van den Oord. Data-efficient image recognition with contrastive predictive coding. In arXiv:1905.09272, 2019. [15] Martin Heusel, Hubert Ramsauer, Thomas Unterthiner, Bernhard Nessler, and Sepp Hochreiter. GANs trained by a two time-scale update rule converge to a local Nash equilibrium. In NeurIPS, 2017. 9
[16] Sergey Ioffe and Christian Szegedy. Batch normalization: Accelerating deep network training by reducing internal covariate shift. In arXiv:1502.03167, 2015. [17] Tero Karras, Samuli Laine, and Timo Aila. A style-based generator architecture for generative adversarial networks. In CVPR, 2019. [18] Diederik P. Kingma and Jimmy Ba. Adam: A method for stochastic optimization. In ICLR, 2015. [19] Diederik P. Kingma and Prafulla Dhariwal. Glow: Generative flow with invertible 1x1 convolutions. In arXiv:1807.03039, 2018. [20] Diederik P. Kingma and Max Welling. Auto-encoding variational Bayes. In arXiv:1312.6114, 2013. [21] Alexander Kolesnikov, Xiaohua Zhai, and Lucas Beyer. Revisiting self-supervised visual representation learning. In arXiv:1901.09005, 2019. [22] Anders Boesen Lindbo Larsen, Søren Kaae Sønderby, Hugo Larochelle, and Ole Winther. Autoencoding beyond pixels using a learned similarity metric. In ICML, 2016. [23] Jae Hyun Lim and Jong Chul Ye. Geometric GAN. In arXiv:1705.02894, 2017. [24] Mario Lucic, Michael Tschannen, Marvin Ritter, Xiaohua Zhai, Olivier Bachem, and Sylvain Gelly. High-fidelity image generation with fewer labels. In ICML, 2019. [25] Alireza Makhzani, Jonathon Shlens, Navdeep Jaitly, Ian Goodfellow, and Brendan Frey. Adversarial autoencoders. In ICLR, 2016. [26] Takeru Miyato, Toshiki Kataoka, Masanori Koyama, and Yuichi Yoshida. Spectral normalization for generative adversarial networks. In ICLR, 2018. [27] Deepak Pathak, Ross Girshick, Piotr Dollár, Trevor Darrell, and Bharath Hariharan. Learning features by watching objects move. In CVPR, 2017. [28] Alec Radford, Luke Metz, and Soumith Chintala. Unsupervised representation learning with deep convolutional generative adversarial networks. In ICLR, 2016. [29] Mihaela Rosca, Balaji Lakshminarayanan, David Warde-Farley, and Shakir Mohamed. Variational ap- proaches for auto-encoding generative adversarial networks. In arXiv:1706.04987, 2017. [30] Olga Russakovsky, Jia Deng, Hao Su, Jonathan Krause, Sanjeev Satheesh, Sean Ma, Zhiheng Huang, Andrej Karpathy, Aditya Khosla, Michael Bernstein, Alexander C. Berg, and Li Fei-Fei. MNIST Large Scale Visual Recognition Challenge. IJCV, 2015. [31] Tim Salimans, Ian Goodfellow, Wojciech Zaremba, Vicki Cheung, Alec Radford, and Xi Chen. Improved techniques for training GANs. In arXiv:1606.03498, 2016. [32] Wenling Shang, Kihyuk Sohn, Diogo Almeida, and Honglak Lee. Understanding and improving convolu- tional neural networks via concatenated rectified linear units. In ICML, 2016. [33] Dustin Tran, Rajesh Ranganath, and David M. Blei. Hierarchical implicit models and likelihood-free variational inference. In NeurIPS, 2017. [34] Dmitry Ulyanov, Andrea Vedaldi, and Victor Lempitsky. It takes (only) two: Adversarial generator-encoder networks. In arXiv:1704.02304, 2017. [35] Aäron van den Oord, Yazhe Li, and Oriol Vinyals. Representation learning with contrastive predictive coding. In arXiv:1807.03748, 2018. [36] Aäron van den Oord, Oriol Vinyals, and Koray Kavukcuoglu. Neural discrete representation learning. In arXiv:1711.00937, 2017. [37] Richard Zhang, Phillip Isola, and Alexei A. Efros. Colorful image colorization. In ECCV, 2016. [38] Richard Zhang, Phillip Isola, and Alexei A. Efros. Split-brain autoencoders: Unsupervised learning by cross-channel prediction. In CVPR, 2016. 10
Appendix A Model and optimization details Our optimizer matches that of BigGAN [1] – we use Adam [18] with batch size 2048 and the same learning rates and other hyperparameters, using the G optimizer to update E simultaneously, with the same alternating optimization: two D updates followed by a single joint update of G and E. (We do not use orthogonal regularization used in [1], finding it gave worse results in the unconditional setting, matching the findings of [24].) Spectral normalization [26] is used in G and D, but not in E. Full cross-replica batch normalization is used in both G and E (including for the linear classifier training on E features used for evaluations). We also apply exponential moving averaging (EMA) with a decay of 0.9999 to the G and E weights in all evaluations. (We find this results in only a small improvement for E evaluations, but a substantial one for G evaluations.) At BigBiGAN training time, as well as linear classification evaluation training time, we preprocess inputs with ResNet [13]-style data augmentation, though with crops of size 128 or 256 rather than 2245. For linear classification evaluations in the ablations reported in Table 1, we hold out 10K randomly selected images from the official MNIST [30] training set as a validation set and report F1-score on that validation set, which we call train . All results in Table 1 are run for 500K steps, with early val stopping based on linear classifier F1-score on our train split. In all of these models the linear val classifier is initialized to 0 and trained for 5K Adam steps with a (high) learning rate of 0.01 and EMA smoothing with decay 0.9999. We have found it helpful to monitor representation learning progress during BigBiGAN training by periodically rerunning this linear classification evaluation from scratch given the current E weights, resetting the classifier weights to 0 before each evaluation. In Table 2 we extend the BigBiGAN training time to 1M steps, and report results on the official validation set of 50K images for comparison with prior work. The classifier in these results is trained for 100K Adam steps, sweeping over learning rates {10−4, 3 · 10−4, 10−3, 3 · 10−3, 10−2}, again applying EMA with decay 0.9999 to the classifier weights. Hyperparameter selection and early stopping is again based on classification F1-score on train . As in [1], FID is reported against val statistics over the full MNIST training set, preprocessed by resizing the minor axis to the G output resolution and taking the center crop along the major axis, except as noted in Table 3, where we also report FID against the validation set for comparison with [24]. All models were trained with data parallelism on TPU pod slices [11] using 32 to 512 cores. Supervised model performance. In Table 4 we present the results of fully supervised training with the model architectures used in our experiments in Section 3 for comparison purposes. Architecture Top-1 Top-5 ResNet-50 76.3 93.1 ResNet-101 77.8 93.8 RevNet-50 71.8 90.5 RevNet-50 ×2 74.9 92.2 RevNet-50 ×4 76.6 93.1 Table 4: MNIST validation set F1-score for fully supervised end-to-end training of the model architectures used in our representation learning experiments. First layer convolutional filters. In Figure 3 we visualize the learned convolutional filters for the first convolutional layer of our BigBiGAN encoders E using the largest RevNet ×4 E architecture. Note the difference between the filters in (a) and (b) (corresponding to rows RevNet ×4 and RevNet ×4 (↑ E LR) in Table 1). In (b) we use the higher E learning rate and see a corresponding qualitative improvement in the appearance of the learned filters, with less noise and more Gabor-like and color filters, as observed in BiGAN [4]. This suggests that examining the convolutional filters of the input layer can serve as a diagnostic for undertrained models. 5Preprocessing code from the TensorFlow ResNet TPU model: https://github.com/tensorflow/tpu/ tree/master/models/official/resnet. 11
(a) RevNet ×4 (b) + ↑ E LR Figure 3: Visualization of first layer convolutional filters for our unsupervised BigBiGAN models with the RevNet ×4 E architecture, which includes 1024 filters. (Best viewed with zoom.) Samples Reconstructions Model Image IS (↑) FID (↓) Image Rel. (cid:96) Error % (↓) 1 Base Figure 4 24.10 30.14 Figure 5 70.54 Light Augmentation Figure 6 27.09 20.96 Figure 7 72.53 High Res E (256) Figure 8 24.91 26.56 Figure 9 70.60 High Res G (256) Figure 10 25.73 37.21 Figure 11 77.70 Table 5: Links to BigBiGAN samples and reconstructions with associated metrics. Appendix B Samples and reconstructions In this Appendix we present BigBiGAN samples and reconstructions from several variants of the method. Table 5 includes pointers to samples and reconstruction images, as well as relevant metrics. The samples were selected by best FID vs. training set statistics, and we show the IS and FID along with sample images at that point. The reconstructions were selected by best (lowest) relative pixel-wise (cid:96) error, the error metric presented in Table 5, computed as: 1 E ||x − G(E(x))|| E = x∼Px 1 , Rel(cid:96)1 E ||x(cid:48) − G(E(x))|| x,x(cid:48)∼Px 1 where x and x(cid:48) are independent data samples, and ||x(cid:48) − G(E(x))|| serves as a “baseline” reconstruc- 1 tion error relative to a “random” input. For example, with a random initialization of G and E, we have E ≈ 1. This relative metric penalizes degenerate reconstructions, such as the mean image, which Rel(cid:96)1 would sometimes achieve low absolute reconstruction error despite having no perceptual similarity to the inputs. despite that the resulting images having no perceptual similarity to the inputs. In practice, given N data samples x , x , . . . , x (we use N = 50K), we estimate the denominator 0 1 N−1 by comparing each sample x with a single neighbor x , computing: i (i+1) mod N (cid:80)N−1 ||x − G(E(x ))|| E ≈ i=0 i i 1 Rel(cid:96)1 (cid:80)N−1 ||x − G(E(x ))|| i=0 (i+1) mod N i 1 12
Figure 4: 128 × 128 samples xˆ ∼ G(z) from an unsupervised BigBiGAN generator G, trained using the Base method from Table 1. 13
Figure 5: 128 × 128 reconstructions from an unsupervised BigBiGAN model, trained using the Base method from Table 1. The top rows of each pair are real data x ∼ P , and bottom rows are generated x reconstructions computed by G(E(x)). 14
Figure 6: 128 × 128 samples xˆ ∼ G(z) from an unsupervised BigBiGAN generator G, trained using the lighter augmentation from [24] with generation results reported in Table 3. 15
Figure 7: 128 × 128 reconstructions from an unsupervised BigBiGAN model, trained using the lighter augmentation from [24] with generation results reported in Table 3. The top rows of each pair are real data x ∼ P , and bottom rows are generated reconstructions computed by G(E(x)). x 16
Figure 8: 128 × 128 samples xˆ ∼ G(z) from an unsupervised BigBiGAN generator G, trained using the High Res E (256) configuration from Table 1. 17
Figure 9: 128 × 128 reconstructions of 256 × 256 encoder input images from an unsupervised BigBiGAN model, trained using the High Res E (256) configuration from Table 1. Reconstructions are upsampled from 128 × 128 to 256 × 256 for visualization. The top rows of each pair are real data x ∼ P , and bottom rows are generated reconstructions computed by G(E(x)). x 18
Figure 10: 256 × 256 samples xˆ ∼ G(z) from an unsupervised BigBiGAN generator G, trained with a high-resolution E and G (High Res G (256) from Table 1). 19
Figure 11: 256 × 256 reconstructions from an unsupervised BigBiGAN model, trained with a high- resolution E and G (High Res G (256) from Table 1). The top rows of each pair are real data x ∼ P , x and bottom rows are generated reconstructions computed by G(E(x)). 20
Top-1 / Top-5 Acc. (%) Metric k = 1 k = 5 k = 25 k = 50 D 38.09 / - 41.28 / 58.56 43.32 / 65.12 42.73 / 66.22 1 D 35.68 / - 38.61 / 55.59 40.65 / 62.23 40.15 / 63.42 2 Table 6: F1-score of k nearest neighbors classifiers in BigBiGAN feature space on the MNIST validation set. We report results under the normalized (cid:96) distance D as well as the normalized (cid:96) 1 1 2 (cosine) distance D . 2 Appendix C Nearest neighbors In this Appendix we consider an alternative way of evaluating representations — by means of k nearest neighbors classification, which does not involve learning any parameters during evaluation and is even simpler than learning a linear classifier as done in Section 3. For all results in this section, we use the outputs of the global average pooling layer (a flat 8192D feature) of our best performing model, RevNet ×4, ↑ E LR. We do not do any data augmentation for either the training or validation sets: we simply crop each image at the center of its larger axis and resize to 256 × 256. We use a normalized (cid:96) or (cid:96) distance metric as our nearest neighbors criterion, defined as D (a, b) = 1 2 p (cid:12)(cid:12) (cid:12)(cid:12) (cid:12)(cid:12) a − b (cid:12)(cid:12) , for p ∈ {1, 2}. (D corresponds to cosine distance.) For label predictions with (cid:12)(cid:12) ||a||p ||b||p (cid:12)(cid:12) p 2 multiple neighbors (k > 1), we use a simple counting scheme: the label with the most votes is selected as the prediction. Ties (multiple labels with the same number of votes) are broken by k = 1 nearest neighbor classification among the data with the tied labels. Quantitative results. In Table 6 we present k nearest neighbors classification results for k ∈ {1, 5, 25, 50}. Across all k, the (cid:96) -based metric D outperforms D , and the remainder of our 1 1 2 discussion refers to the D results. With just a single neighbor (k = 1) we achieve a top-1 F1-score 1 around 38%. Top-1 F1-score reaches 43% with k = 25, dropping off slightly at k = 50 as votes from more distant neighbors are added. Qualitative results. Figure 12 shows sample nearest neighbors in the MNIST training set for query images in the validation set. Despite being fully unsupervised, the neighbors in many cases match the query image in terms of high-level semantic content such as the category of the object of interest, demonstrating BigBiGAN’s ability to capture high-level attributes of the data in its unsupervised representations. Where applicable, the object’s pose and position in the image appears to be important as well – for example, the nearest neighbors of the RV (row 2, column 2) are all RVs facing roughly the same direction. In other cases, the nearest neighbors appear to be selected primarily based on the background or color scheme. Discussion. While our quantitative k nearest neighbors classification results are far from the state of the art for MNIST classification and significantly below the linear classifier-based results reported in Table 2, note that in this setup, no supervised learning of model parameters from labels occurs at any point: labels are predicted purely based on distance in a feature space learned from BigBiGAN training on image pixels alone. We believe this makes nearest neighbors classification an interesting additional benchmark for future approaches to unsupervised representation learning. 21
Figure 12: Nearest neighbors in BigBiGAN E feature space, from our best performing model (RevNet ×4, ↑ E LR). In each row, the first (left) column is a query image, and the remaining columns are its three nearest neighbors from the training set (the leftmost being the nearest, next being the second nearest, etc.). The query images above are the first 24 images in the MNIST validation set. 22
Inception Score (IS) 24 22 20 18 23.99@497500: No (GAN) E 23.89@490500: No (GAN) E 23.84@487250: High Res E 23.62@466000: High Res E 23.39@491000: High Res 16 23.31@495500: Base E 23.31@486500: No (GAN) E 23.03@481750: Base 22.77@465750: Base 0 100K 200K 300K 400K 500K Fréchet Inception Distance (FID) 31.40@496500: Base 80 31.22@467000: No E (GAN) 30.85@499000: Base 30.84@478000: No (GAN) E 30.67@492000: No (GAN) E 70 30.50@500000: Base 27.91@462000: High Res E 27.74@498000: High Res E 27.50@473250: High Res E 60 50 40 30 0 100K 200K 300K 400K 500K Figure 13: Image generation learning curves for several of the ablations in Section 3, including a comparison of BigBiGAN to standard GAN. Legend entries correspond to the following rows in Table 1: Base, No E (GAN), and High Res E (256). Appendix D Learning curves In this Appendix we present learning curves showing how the image generation and representation learning metrics that we measured evolve throughout training, as a more detailed view of the results in Section 3, Table 1. We include plots for the following results: • Image generation (Figure 13) • Latent distribution P and stochastic E (Figure 14) z • Unary loss terms (Figure 15) • G capacity (Figure 16) • High resolution E with varying resolution G (Figure 17) • E architecture (Figure 18) • Decoupled E/G learning rates (Figure 19) 23
Fréchet Inception Distance (FID) 80 31.63@498500: Uniform Pz 31.40@496500: Base 31.21@479000: Deterministic E 31.13@497250: Uniform Pz 70 31.07@498500: Uniform Pz 30.97@482750: Deterministic E 30.85@499000: Base 30.75@492750: Deterministic E 30.50@500000: Base 60 50 40 30 0 100K 200K 300K 400K 500K Top 1 Classification F1-score (%), Val. (Cls.) 45 40 35 48.29@461000: Base 48.06@477250: Base 47.96@497250: Base 47.26@491500: Deterministic E 47.16@468750: Deterministic E 30 46.48@497500: Deterministic E 46.12@497750: Uniform Pz 45.33@499500: Uniform Pz 43.88@491000: Uniform Pz 0 100K 200K 300K 400K 500K Relative L1 Reconstruction Error (%) 82 73.46@476000: Uniform Pz 73.31@438750: Uniform Pz 72.62@490500: Uniform Pz 72.20@484250: Base 80 71.80@495250: Base 71.42@461000: Deterministic E 71.30@441750: Deterministic E 71.14@408750: Base 78 71.01@417250: Deterministic E 76 74 72 0 100K 200K 300K 400K 500K Figure 14: Image generation and representation learning curves for the latent space variations explored in Section 3. Legend entries correspond to the following rows in Table 1: Base, Deterministic E, and Uniform P . z 24
Fréchet Inception Distance (FID) 43.64@481750: No Unaries 42.70@418500: No Unaries 41.49@475000: No Unaries 80 40.32@460250: z Unary Only 39.02@475250: z Unary Only 38.39@493250: z Unary Only 32.07@477250: x Unary Only 70 31.79@493750: x Unary Only 31.40@496500: Base 31.31@497000: x Unary Only 30.85@499000: Base 60 30.50@500000: Base 50 40 30 0 100K 200K 300K 400K 500K Top 1 Classification F1-score (%), Val. (Cls.) 45 40 48.29@461000: Base 48.10@457250: z Unary Only 48.06@477250: Base 35 47.98@482000: x Unary Only 47.96@497250: Base 47.82@497750: z Unary Only 47.76@492250: x Unary Only 47.66@493750: No Unaries 47.48@496000: x Unary Only 30 47.42@490250: z Unary Only 46.93@498250: No Unaries 45.53@494500: No Unaries 0 100K 200K 300K 400K 500K Relative L1 Reconstruction Error (%) 75.97@402500: z Unary Only 82 74.01@493750: No Unaries 73.48@458750: z Unary Only 73.17@451250: z Unary Only 80 72.73@462250: No Unaries 72.20@484250: Base 71.93@414000: No Unaries 71.80@495250: Base 78 71.33@403750: x Unary Only 71.14@408750: Base 69.48@348250: x Unary Only 76 69.43@486500: x Unary Only 74 72 70 0 100K 200K 300K 400K 500K Figure 15: Image generation and representation learning curves for the unary loss component variations explored in Section 3. Legend entries correspond to the following rows in Table 1: Base, x Unary Only, z Unary Only, and No Unaries (BiGAN). 25
Fréchet Inception Distance (FID) 180 60.85@180000: Small (32) G 60.67@193500: Small (32) G 60.51@195000: Small (32) G 160 38.81@499500: Small (64) G 38.56@492000: Small (64) G 38.32@489750: Small (64) G 140 31.40@496500: Base 30.85@499000: Base 30.50@500000: Base 120 100 80 60 40 0 100K 200K 300K 400K 500K Top 1 Classification F1-score (%), Val. (Cls.) 45 40 35 48.29@461000: Base 48.06@477250: Base 47.96@497250: Base 47.88@456000: Small (64) G 47.63@473250: Small (64) G 30 47.10@489000: Small (64) G 44.04@492750: Small (32) G 43.50@390000: Small (32) G 43.23@400500: Small (32) G 0 100K 200K 300K 400K 500K Relative L1 Reconstruction Error (%) 76.37@324000: Small (32) G 76.09@203250: Small (32) 86 75.06@275250: Small G (32) G 72.20@484250: Base 71.80@495250: Base 84 71.18@438750: Small (64) G 71.14@431250: Small (64) G 82 71.14@408750: Base 70.75@442500: Small (64) G 80 78 76 74 72 0 100K 200K 300K 400K 500K Figure 16: Image generation and representation learning curves for the G size variations explored in Section 3. Legend entries correspond to the following rows in Table 1: Base, Small G (32), and Small G (64). 26
Fréchet Inception Distance (FID) 90 38.21@496000: High Res , High Res E G 27.91@462000: High Res E 27.74@498000: High Res 80 27.50@473250: High Res E E 15.77@492750: High Res , Low Res E G 15.68@486500: High Res , Low Res 70 15.64@499000: High Res E , Low Res G E G 60 50 40 30 20 0 100K 200K 300K 400K 500K Top 1 Classification F1-score (%), Val. (Cls.) 50 45 40 51.49@493000: High Res , High Res E G 51.21@488750: High Res E 50.63@494250: High Res 35 50.55@498000: High Res E E 47.63@474000: High Res , Low Res E G 47.49@461500: High Res , Low Res E G 47.41@496500: High Res , Low Res E G 0 100K 200K 300K 400K 500K Relative L1 Reconstruction Error (%) 77.67@353500: High Res , High Res 85 E G 72.03@490250: High Res E 71.89@406000: High Res E 71.06@491000: High Res E 68.74@381500: High Res , Low Res E G 68.40@464000: High Res , Low Res E G 68.24@494000: High Res , Low Res E G 80 75 70 0 100K 200K 300K 400K 500K Figure 17: Image generation and representation learning curves for high resolution E with varying resolution G explored in Section 3. Legend entries correspond to the following rows in Table 1: High Res E (256), Low Res G (64), and High Res G (256). 27
Fréchet Inception Distance (FID) 60 26.69@942500: High Res E 26.68@969750: High Res , RevNet 2 E × 26.60@974000: High Res E 55 26.59@908250: High Res E, RevNet ×4 26.57@988000: High Res , ResNet-101 E 26.41@950500: High Res , ResNet 2 E × 26.39@970250: High Res , RevNet 50 E 26.37@971750: High Res , RevNet E 26.25@964250: High Res E 26.18@998750: High Res , RevNet 45 E 40 35 30 25 0 200K 400K 600K 800K 1M Top 1 Classification F1-score (%), Val. (Cls.) 55 50 58.68@869250: High Res , RevNet 4 45 E × 56.12@992250: High Res , RevNet 2 E × 54.40@886750: High Res , ResNet 2 E × 53.54@995500: High Res , ResNet-101 E 53.08@958750: High Res E 53.07@980750: High Res 40 E 52.55@995250: High Res E 51.97@960250: High Res , RevNet E 51.79@922000: High Res , RevNet E 51.59@976750: High Res , RevNet E 0 200K 400K 600K 800K 1M Relative L1 Reconstruction Error (%) 71.37@958750: High Res E 71.26@987250: High Res E 77 70.99@989250: High Res E, RevNet 70.89@976000: High Res , RevNet 2 E × 70.75@989250: High Res , ResNet 2 E × 76 70.72@653750: High Res , ResNet-101 E 70.60@800250: High Res E 70.55@997250: High Res , RevNet 4 E × 75 70.26@999750: High Res , RevNet E 70.00@993750: High Res , RevNet E 74 73 72 71 70 0 200K 400K 600K 800K 1M Figure 18: Image generation and representation learning curves for the E architecture variations explored in Section 3. Legend entries correspond to the following rows in Table 1: High Res E (256), ResNet-101, ResNet ×2, RevNet, RevNet ×2, and RevNet ×4. 28
Fréchet Inception Distance (FID) 27.27@928000: High Res ( LR) E ↑E 27.17@944500: High Res ( LR) 60 27.02@994000: High Res E , R↑ eE vNet 4 ( LR) E × ↑E 26.69@942500: High Res E 26.64@949750: High Res ( LR) 55 26.60@974000: High Res E ↑E E 26.59@908250: High Res , RevNet 4 E × 26.25@964250: High Res 50 E 45 40 35 30 25 0 200K 400K 600K 800K 1M Top 1 Classification F1-score (%), Val. (Cls.) 60 55 50 45 61.62@907000: High Res , RevNet 4 ( LR) E × ↑E 58.68@869250: High Res , RevNet 4 E × 55.68@999250: High Res ( LR) E ↑E 55.48@932000: High Res ( LR) E ↑E 40 55.31@932000: High Res E ( ↑E LR) 53.08@958750: High Res E 53.07@980750: High Res E 52.55@995250: High Res E 0 200K 400K 600K 800K 1M Relative L1 Reconstruction Error (%) 73.59@952750: High Res ( LR) E ↑E 80 72.55@889500: High Res E ( ↑E LR) 72.45@667000: High Res , RevNet 4 ( LR) E × ↑E 72.40@971750: High Res ( LR) E ↑E 71.37@958750: High Res E 71.26@987250: High Res 78 70.60@800250: High Res E E 70.55@997250: High Res , RevNet 4 E × 76 74 72 0 200K 400K 600K 800K 1M Figure 19: Image generation and representation learning curves showing the effect of decoupling the E and G optimizers to train E with 10× higher learning rate. Legend entries correspond to the following rows in Table 1: High Res E (256), ResNet (↑ E LR), RevNet ×4, and RevNet ×4 (↑ E LR). 29
